#!/usr/bin/env ruby

require 'erb'
require 'optparse'
require 'digest/sha1'
require 'logger'
require 'json'

module TemplateConfigurator
  @@logger = nil
  
  def self.log=(logger)
    @@logger=logger
  end

  def self.log
    @@logger
  end

  class CommandLine
    def initialize
      @logger = Logger.new STDERR

      @options = {}
      @options[:log] = {}
      @options[:template] = {}
      @options[:service] = {}

      args = OptionParser.new do |opts|
        opts.banner = "Usage: #{$0}"

        #
        # Service options
        #
        @options[:service][:command] = '/sbin/service'
        opts.on("--service:command EXECUTABLE", "action to execute to command service (default: #{@options[:service][:command]})") do |executable|
          @options[:service][:command] = executable
        end

        @options[:service][:name] = nil
        opts.on("--service:name INITRC", "initrc used to control service (default: #{@options[:service][:name]})") do |initrc|
          @options[:service][:name] = initrc
        end

        @options[:service][:reload] = 'reload'
        opts.on("--service:reload ACTION", "action to execute to reload service (default: #{@options[:service][:reload]})") do |action|
          @options[:service][:reload] = action
        end

        @options[:service][:restart] = 'restart'
        opts.on("--service:restart ACTION", "action to execute to restart service (default: #{@options[:service][:restart]})") do |action|
          @options[:service][:restart] = action
        end

        @options[:service][:start] = 'start'
        opts.on("--service:start ACTION", "action to execute to start service (default: #{@options[:service][:start]})") do |action|
          @options[:service][:start] = action
        end

        @options[:service][:stop] = 'stop'
        opts.on("--service:stop ACTION", "action to execute to stop service (default: #{@options[:service][:stop]})") do |action|
          @options[:service][:stop] = action
        end


        @options[:service][:retries] = 5
        opts.on("--service:retries NUMBER", "number of attempts to reload service (default: #{@options[:service][:retries]})") do |number|
          @options[:service][:retries] = number.to_i
        end

        @options[:service][:retry_delay] = 2
        opts.on("--service:retry-delay SECS", "seconds to sleep between retries (default: #{@options[:service][:retry_delay]})") do |seconds|
          @options[:service][:retry_delay] = seconds.to_i
        end

        #
        # Template options
        #

        @options[:template][:input_file] = nil
        opts.on("--template:input-file FILE", "Where to read ERB template") do |file|
          @options[:template][:input_file] = file
        end

        @options[:template][:output_file] = nil
        opts.on("--template:output-file FILE", "Where to write the output of the template") do |file|
          @options[:template][:output_file] = file
        end

        @options[:template][:json_file] = nil
        opts.on("--template:json-file FILE", "Base port to initialize haproxy listening for mysql clusters") do |file|
          @options[:template][:json_file] = file
        end

        @options[:template][:commit] = true
        opts.on("--template:[no-]commit", "Commit changes") do |commit|
          @options[:template][:commit] = commit
        end

        #
        # Logging
        #

        @options[:log][:level] = Logger::INFO
        opts.on( '--log:level LEVEL', 'Logging level' ) do|level|
          @options[:log][:level] = Logger.const_get level.upcase
        end

        @options[:log][:file] = STDERR
        opts.on( '--log:file FILE', 'Write logs to FILE (default: STDERR)' ) do|file|
          @options[:log][:file] = File.open(file, File::WRONLY | File::APPEND | File::CREAT)
        end

        @options[:log][:age] = 7
        opts.on( '--log:age DAYS', "Rotate logs after DAYS pass (default: #{@options[:log][:age]})" ) do|days|
          @options[:log][:age] = days.to_i
        end

        @options[:log][:size] = 1024*1024*10
        opts.on( '--log:size SIZE', 'Rotate logs after the grow past SIZE bytes' ) do |size|
          @options[:log][:size] = size.to_i
        end


        #
        # General options
        #

        opts.on( '-V', '--version', 'Display version information' ) do
          puts "Template Configurator #{TemplateConfigurator::VERSION}"
          puts "Copyright (C) 2012 Erik Osterman <e@osterman.com>"
          puts "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>"
          puts "This is free software: you are free to change and redistribute it."
          puts "There is NO WARRANTY, to the extent permitted by law."
          exit
        end

        opts.on( '-h', '--help', 'Display this screen' ) do
          puts opts
          exit
        end

      end

      begin
        args.parse!
        raise OptionParser::MissingArgument.new("--template:input-file") if @options[:template][:input_file].nil?
      rescue OptionParser::MissingArgument => e
        puts e.message
        puts args
        exit 1
      rescue OptionParser::InvalidOption => e
        puts e.message
        puts args
        exit 1
      end
    end

    def execute
      @processor = Processor.new(@options)
      TemplateConfigurator.log = Logger.new(@options[:log][:file], @options[:log][:age], @options[:log][:size])
      TemplateConfigurator.log.level = @options[:log][:level]
      begin
        @processor.render
      rescue Interrupt => e
        TemplateConfigurator.log.info("Aborting")
      rescue NameError => e
        TemplateConfigurator.log.fatal(e.message)
        TemplateConfigurator.log.debug(e.backtrace.join("\n"))
        exit(1)
      rescue Exception => e
        TemplateConfigurator.log.fatal("#{e.class}: #{e.message}")
        TemplateConfigurator.log.debug(e.backtrace.join("\n"))
        exit(1)
      end
      exit(0)
    end
  end

  class ServiceException < Exception
    attr_accessor :code, :output
    def initialize(msg, code, output)
      @code = code
      @output = output
      super(msg)
    end
  end

  class Service
    attr_accessor :options
    def initialize options
      @options = options
    end

    def command action
      ShellUtils.join([@options[:service][:command], @options[:service][:name], action])
    end

    def execute command
      output = %x{#{command}}
      exit_code = $?.exitstatus
      raise ServiceException.new("execution failed; #{command} exited with status #{exit_code}", exit_code, output) unless exit_code == 0
      return output
    end

    def status
      execute command @options[:status]
    end

    def restart
      execute command @options[:restart]
    end

    def reload
      execute command @options[:reload]
    end

    def start
      execute command @options[:start]
    end

    def stop
      execute command @options[:stop]
    end

    def conditional_reload
      # Attempt to reload service if it's running, otherwise start it.
      @options[:retries].times do 
        begin
          status_output = self.status
          TemplateConfigurator.log.debug("#{@options[:name]} is running")
          # If the configuration has changed, reload config
          begin 
            reload_output = self.reload
            TemplateConfigurator.log.debug("Reload command succeeded")
            return reload_output
          rescue ServiceException => e
            TemplateConfigurator.log.error(e.message)
            TemplateConfigurator.log.error(e.output)
          end
        rescue ServiceException => e
          # service is not running
          TemplateConfigurator.log.error(e.message)
          TemplateConfigurator.log.error(e.output)
          begin
            start_output = self.start
            TemplateConfigurator.log.debug("Start command succeeded")
            return start_output
          rescue ServiceException => e
            TemplateConfigurator.log.error(e.message)
            TemplateConfigurator.log.error(e.output)
          end
        end
        sleep(@options[:retry_delay])
      end
      # Everything else failed. Try a restart
      return self.restart
    end
  end

  class Processor
    attr_accessor :service, :options, :locks

    def lock file
      @locks[:file] = File.open(file, File::RDWR|File::CREAT, 0644) 
      @locks[:file].flock(File::LOCK_EX)
      @locks[:file]
    end

    def unlock
      @locks[:file].flock(File::LOCK_UN)
      @locks[:file]
    end

    def initialize(options)
      @options = options
      @locks = {}
      @service = Service.new(@options[:service])
    end

    def render
      @data = {}
      unless @options[:template][:json_file].nil?
        json_fh = lock(@options[:template][:json_file])
        @data = JSON.parse(json_fh.read)
      end
      TemplateConfigurator.log.debug("json:[#{@data.inspect}]")
      template = ERB.new(File.read(@options[:template][:input_file]), 0, '%<>')

      if @options[:template][:output_file].nil?
        output_fh = STDOUT
        old_output = ""
      else
        output_fh = lock(@options[:template][:output_file])
        old_output = output_fh.read
      end
      
      new_output = template.result(binding)

      new_sha1 = Digest::SHA1.hexdigest(new_output)
      old_sha1 = Digest::SHA1.hexdigest(old_output)

      TemplateConfigurator.log.debug("old_sha1:#{old_sha1} new_sha1:#{new_sha1}")

      if new_sha1 == old_sha1
        TemplateConfigurator.log.debug("SHA1 checksum unchanged")
      else
        TemplateConfigurator.log.info "SHA1 checksum changed"
        # Write the new configuration
        if @options[:template][:commit] && !@options[:template][:output_file].nil?
          TemplateConfigurator.log.debug("writing new configuation (#{new_output.length} bytes)")
          output_fh.truncate
          output_fh.write(new_output)
          reload
        else
          TemplateConfigurator.log.debug("Not attemptig service reload due to missing output file parameter")
          output_fh.write new_output
        end
      end

      def reload
        if @options[:service][:name].nil?
          TemplateConfigurator.log.info("service not specified; skipping reload")
        else
          begin
            @service.conditional_reload
          rescue ServiceException => e
            TemplateConfigurator.log.error(e.message)
            TemplateConfigurator.log.error(e.output)
          end
        end
      end
    end
  end
end

command_line = TemplateConfigurator::CommandLine.new
command_line.execute
